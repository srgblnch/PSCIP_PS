static const char *ClassId    = "$Id: $";
static const char *CvsPath    = "$Source: $";
static const char *SvnPath    = "$HeadURL: $";
static const char *RcsId     = "$Header:  $";
static const char *TagName   = "$Name:  $";
static const char *HttpServer= "http://www.esrf.fr/computing/cs/tango/tango_doc/ds_doc/";
//+=============================================================================
//
// file :        PSI_PCClass.cpp
//
// description : C++ source for the PSI_PCClass. A singleton
//               class derived from DeviceClass. It implements the
//               command list and all properties and methods required
//               by the PSI_PC once per process.
//
// project :     TANGO Device Server
//
// $Author:  $
//
// $Revision:  $
//
// $Log:  $
//
// copyleft :   European Synchrotron Radiation Facility
//              BP 220, Grenoble 38043
//              FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================


#include <tango.h>

#include <PSI_PC.h>
#include <PSI_PCClass.h>


//+----------------------------------------------------------------------------
/**
 *	Create PSI_PCClass singleton and return it in a C function for Python usage
 */
//+----------------------------------------------------------------------------
extern "C" {
#ifdef WIN32

__declspec(dllexport)

#endif

	Tango::DeviceClass *_create_PSI_PC_class(const char *name) {
		return PSI_PC_ns::PSI_PCClass::init(name);
	}
}


namespace PSI_PC_ns
{
//+----------------------------------------------------------------------------
//
// method : 		UpdateCmd::execute()
// 
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo   
//
// in : - device : The device on which the command must be executed
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *UpdateCmd::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "UpdateCmd::execute(): arrived" << endl;

	((static_cast<PSI_PC *>(device))->update());
	return new CORBA::Any();
}


//+----------------------------------------------------------------------------
//
// method : 		ConnectCmd::execute()
//
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *ConnectCmd::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "ConnectCmd::execute(): arrived" << endl;

	((static_cast<PSI_PC *>(device))->connect());
	return new CORBA::Any();
}

//+----------------------------------------------------------------------------
//
// method : 		InterlockStatusCmd::execute()
//
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *InterlockStatusCmd::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "InterlockStatusCmd::execute(): arrived" << endl;

	return insert((static_cast<PSI_PC *>(device))->interlock_status());
}

//+----------------------------------------------------------------------------
//
// method : 		EnableInterlocksCmd::execute()
//
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *EnableInterlocksCmd::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "EnableInterlocksCmd::execute(): arrived" << endl;

	((static_cast<PSI_PC *>(device))->enable_interlocks());
	return new CORBA::Any();
}

//+----------------------------------------------------------------------------
//
// method : 		DisableInterlocksCmd::execute()
//
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *DisableInterlocksCmd::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "DisableInterlocksCmd::execute(): arrived" << endl;

	((static_cast<PSI_PC *>(device))->disable_interlocks());
	return new CORBA::Any();
}

//+----------------------------------------------------------------------------
//
// method : 		ResetInterlocksCmd::execute()
//
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *ResetInterlocksCmd::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "ResetInterlocksCmd::execute(): arrived" << endl;

	((static_cast<PSI_PC *>(device))->reset_interlocks());
	return new CORBA::Any();
}

//+----------------------------------------------------------------------------
//
// method : 		StartSoftwareWaveformClass::execute()
//
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo
//
// in : - device : The device on which the command must be executed
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *StartSoftwareWaveformClass::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "StartSoftwareWaveformClass::execute(): arrived" << endl;

	((static_cast<PSI_PC *>(device))->start_software_waveform());
	return new CORBA::Any();
}

//+----------------------------------------------------------------------------
//
// method : 		StopSoftwareWaveformClass::execute()
//
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo
//
// in : - device : The device on which the command must be executed
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *StopSoftwareWaveformClass::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "StopSoftwareWaveformClass::execute(): arrived" << endl;

	((static_cast<PSI_PC *>(device))->stop_software_waveform());
	return new CORBA::Any();
}

//+----------------------------------------------------------------------------
//
// method : 		Read_PSC_registerCmd::execute()
//
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *Read_PSC_registerCmd::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "Read_PSC_registerCmd::execute(): arrived" << endl;

	Tango::DevString	argin;
	extract(in_any, argin);

	return insert((static_cast<PSI_PC *>(device))->read__psc_register(argin));
}






//+----------------------------------------------------------------------------
//
// method : 		OnClass::execute()
//
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *OnClass::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "OnClass::execute(): arrived" << endl;

	((static_cast<PSI_PC *>(device))->on());
	return new CORBA::Any();
}

//+----------------------------------------------------------------------------
//
// method : 		OffClass::execute()
//
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *OffClass::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "OffClass::execute(): arrived" << endl;

	((static_cast<PSI_PC *>(device))->off());
	return new CORBA::Any();
}




//+----------------------------------------------------------------------------
//
// method : 		ResetClass::execute()
//
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *ResetClass::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "ResetClass::execute(): arrived" << endl;

	((static_cast<PSI_PC *>(device))->reset());
	return new CORBA::Any();
}



//
//----------------------------------------------------------------
//	Initialize pointer for singleton pattern
//----------------------------------------------------------------
//
PSI_PCClass *PSI_PCClass::_instance = NULL;

//+----------------------------------------------------------------------------
//
// method : 		PSI_PCClass::PSI_PCClass(string &s)
//
// description : 	constructor for the PSI_PCClass
//
// in : - s : The class name
//
//-----------------------------------------------------------------------------
PSI_PCClass::PSI_PCClass(string &s):DeviceClass(s)
{

	cout2 << "Entering PSI_PCClass constructor" << endl;
	set_default_property();
	get_class_property();
	write_class_property();

	cout2 << "Leaving PSI_PCClass constructor" << endl;

}
//+----------------------------------------------------------------------------
//
// method : 		PSI_PCClass::~PSI_PCClass()
//
// description : 	destructor for the PSI_PCClass
//
//-----------------------------------------------------------------------------
PSI_PCClass::~PSI_PCClass()
{
	_instance = NULL;
}

//+----------------------------------------------------------------------------
//
// method : 		PSI_PCClass::instance
// 
// description : 	Create the object if not already done. Otherwise, just
//			return a pointer to the object
//
// in : - name : The class name
//
//-----------------------------------------------------------------------------
PSI_PCClass *PSI_PCClass::init(const char *name)
{
	if (_instance == NULL)
	{
		try
		{
			string s(name);
			_instance = new PSI_PCClass(s);
		}
		catch (bad_alloc)
		{
			throw;
		}		
	}		
	return _instance;
}

PSI_PCClass *PSI_PCClass::instance()
{
	if (_instance == NULL)
	{
		cerr << "Class is not initialised !!" << endl;
		exit(-1);
	}
	return _instance;
}

//+----------------------------------------------------------------------------
//
// method : 		PSI_PCClass::command_factory
// 
// description : 	Create the command object(s) and store them in the 
//			command list
//
//-----------------------------------------------------------------------------
void PSI_PCClass::command_factory()
{
	command_list.push_back(new OnClass("On",
		Tango::DEV_VOID, Tango::DEV_VOID,
		"",
		"",
		Tango::OPERATOR));
	command_list.push_back(new OffClass("Off",
		Tango::DEV_VOID, Tango::DEV_VOID,
		"",
		"",
		Tango::OPERATOR));
	command_list.push_back(new ResetClass("Reset",
		Tango::DEV_VOID, Tango::DEV_VOID,
		"",
		"",
		Tango::OPERATOR));
	command_list.push_back(new ResetInterlocksCmd("ResetInterlocks",
		Tango::DEV_VOID, Tango::DEV_VOID,
		"",
		"",
		Tango::OPERATOR));
	command_list.push_back(new DisableInterlocksCmd("DisableInterlocks",
		Tango::DEV_VOID, Tango::DEV_VOID,
		"",
		"",
		Tango::OPERATOR));
	command_list.push_back(new EnableInterlocksCmd("EnableInterlocks",
		Tango::DEV_VOID, Tango::DEV_VOID,
		"",
		"",
		Tango::OPERATOR));
	command_list.push_back(new InterlockStatusCmd("InterlockStatus",
		Tango::DEV_VOID, Tango::DEV_STRING,
		"",
		"Interlocks Status",
		Tango::OPERATOR));
	command_list.push_back(new Read_PSC_registerCmd("Read_PSC_register",
		Tango::DEV_STRING, Tango::DEV_STRING,
		"Register address and return format (f-float,i-integer,x-hex, by default x), ex input: 0x00 x - address 0, return value hex",
		"Data, hexadecimal",
		Tango::EXPERT));
	command_list.push_back(new StopSoftwareWaveformClass("StopSoftwareWaveform",
		Tango::DEV_VOID, Tango::DEV_VOID,
		"",
		"",
		Tango::OPERATOR));
	command_list.push_back(new StartSoftwareWaveformClass("StartSoftwareWaveform",
		Tango::DEV_VOID, Tango::DEV_VOID,
		"",
		"",
		Tango::OPERATOR));
	command_list.push_back(new ConnectCmd("Connect",
		Tango::DEV_VOID, Tango::DEV_VOID,
		"",
		"",
		Tango::OPERATOR));
	command_list.push_back(new UpdateCmd("Update",
		Tango::DEV_VOID, Tango::DEV_VOID,
		"",
		"",
		Tango::EXPERT));

	//	add polling if any
	for (unsigned int i=0 ; i<command_list.size(); i++)
	{
		if (command_list[i]->get_name()=="Update")
			command_list[i]->set_polling_period(100);
	}
}

//+----------------------------------------------------------------------------
//
// method : 		PSI_PCClass::get_class_property
// 
// description : 	Get the class property for specified name.
//
// in :		string	name : The property name
//
//+----------------------------------------------------------------------------
Tango::DbDatum PSI_PCClass::get_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_prop.size() ; i++)
		if (cl_prop[i].name == prop_name)
			return cl_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}
//+----------------------------------------------------------------------------
//
// method : 		PSI_PCClass::get_default_device_property()
// 
// description : 	Return the default value for device property.
//
//-----------------------------------------------------------------------------
Tango::DbDatum PSI_PCClass::get_default_device_property(string &prop_name)
{
	for (unsigned int i=0 ; i<dev_def_prop.size() ; i++)
		if (dev_def_prop[i].name == prop_name)
			return dev_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}

//+----------------------------------------------------------------------------
//
// method : 		PSI_PCClass::get_default_class_property()
// 
// description : 	Return the default value for class property.
//
//-----------------------------------------------------------------------------
Tango::DbDatum PSI_PCClass::get_default_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_def_prop.size() ; i++)
		if (cl_def_prop[i].name == prop_name)
			return cl_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}
//+----------------------------------------------------------------------------
//
// method : 		PSI_PCClass::device_factory
// 
// description : 	Create the device object(s) and store them in the 
//			device list
//
// in :		Tango::DevVarStringArray *devlist_ptr : The device name list
//
//-----------------------------------------------------------------------------
void PSI_PCClass::device_factory(const Tango::DevVarStringArray *devlist_ptr)
{

	//	Create all devices.(Automatic code generation)
	//-------------------------------------------------------------
	for (unsigned long i=0 ; i < devlist_ptr->length() ; i++)
	{
		cout4 << "Device name : " << (*devlist_ptr)[i].in() << endl;
						
		// Create devices and add it into the device list
		//----------------------------------------------------
		device_list.push_back(new PSI_PC(this, (*devlist_ptr)[i]));							 

		// Export device to the outside world
		// Check before if database used.
		//---------------------------------------------
		if ((Tango::Util::_UseDb == true) && (Tango::Util::_FileDb == false))
			export_device(device_list.back());
		else
			export_device(device_list.back(), (*devlist_ptr)[i]);
	}
	//	End of Automatic code generation
	//-------------------------------------------------------------

}
//+----------------------------------------------------------------------------
//	Method: PSI_PCClass::attribute_factory(vector<Tango::Attr *> &att_list)
//-----------------------------------------------------------------------------
void PSI_PCClass::attribute_factory(vector<Tango::Attr *> &att_list)
{
	//	Attribute : CurrentSetpoint
	CurrentSetpointAttrib	*current_setpoint = new CurrentSetpointAttrib();
	Tango::UserDefaultAttrProp	current_setpoint_prop;
	current_setpoint_prop.set_delta_val("0.000001");
	current_setpoint->set_default_properties(current_setpoint_prop);
	current_setpoint->set_polling_period(200);
	att_list.push_back(current_setpoint);

	//	Attribute : Voltage
	VoltageAttrib	*voltage = new VoltageAttrib();
	Tango::UserDefaultAttrProp	voltage_prop;
	voltage_prop.set_delta_val("0.01");
	voltage->set_default_properties(voltage_prop);
	voltage->set_polling_period(200);
	att_list.push_back(voltage);

	//	Attribute : RemoteMode
	RemoteModeAttrib	*remote_mode = new RemoteModeAttrib();
	att_list.push_back(remote_mode);

	//	Attribute : Current
	CurrentAttrib	*current = new CurrentAttrib();
	Tango::UserDefaultAttrProp	current_prop;
	current_prop.set_delta_val("0.01");
	current->set_default_properties(current_prop);
	current->set_polling_period(200);
	att_list.push_back(current);

	//	Attribute : CurrentOffset
	CurrentOffsetAttrib	*current_offset = new CurrentOffsetAttrib();
	current_offset->set_memorized();
	current_offset->set_memorized_init(true);
	att_list.push_back(current_offset);

	//	Attribute : I
	IAttrib	*i = new IAttrib();
	Tango::UserDefaultAttrProp	i_prop;
	i_prop.set_unit("A");
	i->set_default_properties(i_prop);
	i->set_disp_level(Tango::EXPERT);
	att_list.push_back(i);

	//	Attribute : SoftwareWaveform
	SoftwareWaveformAttrib	*software_waveform = new SoftwareWaveformAttrib();
	att_list.push_back(software_waveform);

	//	Attribute : ErrorCodes
	ErrorCodesAttrib	*error_codes = new ErrorCodesAttrib();
	att_list.push_back(error_codes);

	//	Attribute : ErrorLabel
	ErrorLabelAttrib	*error_label = new ErrorLabelAttrib();
	att_list.push_back(error_label);

	//	Attribute : Errors
	ErrorsAttrib	*errors = new ErrorsAttrib();
	att_list.push_back(errors);

	//	End of Automatic code generation
	//-------------------------------------------------------------
}

//+----------------------------------------------------------------------------
//
// method : 		PSI_PCClass::get_class_property()
//
// description : 	Read the class properties from database.
//
//-----------------------------------------------------------------------------
void PSI_PCClass::get_class_property()
{
	//	Initialize your default values here (if not done with  POGO).
	//------------------------------------------------------------------

	//	Read class properties from database.(Automatic code generation)
	//------------------------------------------------------------------
	cl_prop.push_back(Tango::DbDatum("Interlock1"));
	cl_prop.push_back(Tango::DbDatum("Interlock2"));

	//	Call database and extract values
	//--------------------------------------------
	if (Tango::Util::instance()->_UseDb==true)
		get_db_class()->get_property(cl_prop);
	Tango::DbDatum	def_prop;
	int	i = -1;

	//	Try to extract Interlock1 value
	if (cl_prop[++i].is_empty()==false)	cl_prop[i]  >>  interlock1;
	else
	{
		//	Check default value for Interlock1
		def_prop = get_default_class_property(cl_prop[i].name);
		if (def_prop.is_empty()==false)
		{
			def_prop  >>  interlock1;
			cl_prop[i]  <<  interlock1;
		}
	}

	//	Try to extract Interlock2 value
	if (cl_prop[++i].is_empty()==false)	cl_prop[i]  >>  interlock2;
	else
	{
		//	Check default value for Interlock2
		def_prop = get_default_class_property(cl_prop[i].name);
		if (def_prop.is_empty()==false)
		{
			def_prop  >>  interlock2;
			cl_prop[i]  <<  interlock2;
		}
	}

	//	End of Automatic code generation
	//------------------------------------------------------------------

}

//+----------------------------------------------------------------------------
//
// method : 	PSI_PCClass::set_default_property
// 
// description: Set default property (class and device) for wizard.
//              For each property, add to wizard property name and description
//              If default value has been set, add it to wizard property and
//              store it in a DbDatum.
//
//-----------------------------------------------------------------------------
void PSI_PCClass::set_default_property()
{
	string	prop_name;
	string	prop_desc;
	string	prop_def;

	vector<string>	vect_data;
	//	Set Default Class Properties
	prop_name = "Interlock1";
	prop_desc = "";
	prop_def  = "external interlock 1";
	vect_data.clear();
	vect_data.push_back("external interlock 1");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		cl_def_prop.push_back(data);
		add_wiz_class_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_class_prop(prop_name, prop_desc);

	prop_name = "Interlock2";
	prop_desc = "message to be shown for external interlock 2";
	prop_def  = "external interlock 2";
	vect_data.clear();
	vect_data.push_back("external interlock 2");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		cl_def_prop.push_back(data);
		add_wiz_class_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_class_prop(prop_name, prop_desc);

	//	Set Default Device Properties
	prop_name = "Channel";
	prop_desc = "Channel used of PC";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "FODevice";
	prop_desc = "BName of the Linux character / block device.";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "Interlock1";
	prop_desc = "Defines which bit of digital input register indicates temperature interlock";
	prop_def  = "external interlock 1";
	vect_data.clear();
	vect_data.push_back("external interlock 1");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "Interlock2";
	prop_desc = "message to be shown for external interlock 2";
	prop_def  = "external interlock 2";
	vect_data.clear();
	vect_data.push_back("external interlock 2");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "TangoDevice";
	prop_desc = "name of the python serial device server responisble for serial communication";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "ConnectionType";
	prop_desc = "You can choose the kind of connection the DS \"talks\" with PSC:\n0 -> fiber\n1 -> serial (RS232)\n\nTo run RS232 you need to create pySerial DS";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

	prop_name = "CurrentFactor";
	prop_desc = "scaling factor ( f ):\nIref = f * ( I_idal + o )\n";
	prop_def  = "1";
	vect_data.clear();
	vect_data.push_back("1");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);

}
//+----------------------------------------------------------------------------
//
// method : 		PSI_PCClass::write_class_property
// 
// description : 	Set class description as property in database
//
//-----------------------------------------------------------------------------
void PSI_PCClass::write_class_property()
{
	//	First time, check if database used
	//--------------------------------------------
	if (Tango::Util::_UseDb == false)
		return;

	Tango::DbData	data;
	string	classname = get_name();
	string	header;
	string::size_type	start, end;

	//	Put title
	Tango::DbDatum	title("ProjectTitle");
	string	str_title("PSI power supplies");
	title << str_title;
	data.push_back(title);

	//	Put Description
	Tango::DbDatum	description("Description");
	vector<string>	str_desc;
	str_desc.push_back("<strong><i>Control of SR power supplies.. The Device Server is meant to provide control of  PSI Power Supply Controllers. The DS is basic/universal, it means that it can be used as a base for developing Device Servers for PSI PSC intended for specific usage which requires implementing additional functions (ex. upload/download waveform).</i></strong>");
	str_desc.push_back("<Br>");
	str_desc.push_back("<Br>");
	str_desc.push_back("The Device Server can use two types of hardware connection to communicate with PSI PSC: serial (RS232) or fiber. The connection type is determined by setting the property: ConnectionType (0 for fiber and 1 for serial).<Br>");
	str_desc.push_back("<Br>");
	str_desc.push_back("For simplicity, PSC DS connected by serial connection will be called serial DS, PSC DS connected by fiber connection will be called fiber DS.<Br>");
	str_desc.push_back("<Br>");
	str_desc.push_back("Serial connection is considered as local and 'service', it is not supposed to be used on normal basis, just in extraordinary cases. <Br>");
	str_desc.push_back("Fiber connection is considered a default connection meant to be used most of the time.<Br>");
	str_desc.push_back("<Br>");
	str_desc.push_back("Fiber connection uses PCI/cPCI Carrier Card. Each card carries two Industrial Pack (IP), each having two channels. Each channel of IP is connected to one PSC. One IP is represented in /dev/ folder as node called pscipX (X  is number).<Br>");
	str_desc.push_back("If fiber connection is to be used, the property 'FODevice' needs to be set (ex '/dev/pscip0') along with 'Channel' property (0 or 1).<Br>");
	str_desc.push_back("<Br>");
	str_desc.push_back("Serial connection uses PySerial Device Server. The property 'TangoDevice' needs to be set inicating the Py Serial name and localization (ex. 'ws/pc-test/ocem00-serial ').<Br>");
	str_desc.push_back("<Br>");
	str_desc.push_back("For the PySerial to work properly,  the following attributes need to be set:<Br>");
	str_desc.push_back("<Br>");
	str_desc.push_back("<Center>");
	str_desc.push_back("<table  border = 2 >");
	str_desc.push_back("<tr bgcolor=#cccccc><td> <strong>Attr name</strong> </td> <td> <strong>value</strong> </td></tr>");
	str_desc.push_back("<tr><td> Bautrate </td> <td> 115200 </td></tr>");
	str_desc.push_back("<tr><td> DataBits </td> <td> 8 </td></tr>");
	str_desc.push_back("<tr><td> Parity </td> <td> odd </td></tr>");
	str_desc.push_back("<tr><td> Port </td> <td> Correct port to which PSC is connected (ex. /dev/ttyR0) </td></tr>");
	str_desc.push_back("<tr><td> StopBits </td> <td> 1 </td></tr>");
	str_desc.push_back("</table>");
	str_desc.push_back("</Center>");
	str_desc.push_back("<Br>");
	str_desc.push_back("<Br>");
	str_desc.push_back("In theory, instead of PySerial DS, any DS can be used instead of PySerial without any changes to PSI SD as long as the following commands are implemented:");
	str_desc.push_back("<ul>");
	str_desc.push_back("<li>'ReadLine' for reading data,");
	str_desc.push_back("<li>'Write' for writing");
	str_desc.push_back("<li>'Open'");
	str_desc.push_back("<li>'Close'");
	str_desc.push_back("<li>'State'");
	str_desc.push_back("</ul>");
	str_desc.push_back("Both connections can be used simultaneously only for reading. When writing, a priority is given to one of the Device Servers  The priority can be only set Serial DS. It means that DS connected by fiber cannot regain writing priority , it has to be granted priority. For safety reasons the priority is granted to serial DS as long as it is connected to PSC. To be precise, the priority for serial DS is granted as soon as it attempts the first write. The priority is set to fiber DS only if serial DS is disconnected from PSC.<Br>");
	str_desc.push_back("<Br>");
	str_desc.push_back("<strong>CAUTION:</strong> <i>If the priority is set to serial DS and an attempt to write is made by fiber DS, the fiber DS gives no error message, it looks as if the operation was successful, however, the value is not written.</i> <Br>");
	str_desc.push_back("<Br>");
	str_desc.push_back("The following documentation is available, which can be useful  for future developers/users:<Br>");
	str_desc.push_back("1)      <a href=\"documentation/Communication_protocol.doc\">Communication_protocol.doc</a> is adescription of communication protocol between DS and PSC<Br>");
	str_desc.push_back("2)      <a href=\"documentation/DSP_SW_R4_User_Documentation English.doc\">DSP_SW_R4_User_Documentation English.doc</a>  is a description of PSI Power Supply Controller (all registers and their meaning, meaning of leds, etc)<Br>");
	str_desc.push_back("3)      <a href=\"documentation/Messages_Codes_en.xls\">Messages_Codes_en.xls</a> explains meaning of error codes from PSC <Br>");
	str_desc.push_back("4)      <a href=\"documentation/pc-architecture.odt\">DS Specification</a> Architecture and Design of the TANGO device server for the Power supplies at ALBA<Br>");
	str_desc.push_back("<p>Detailed documentation describing hardware used is provided");
	str_desc.push_back("with the PSCIP Linux Device Driver.</p>");
	str_desc.push_back("<p></p>");
	str_desc.push_back("<p></p>");
	str_desc.push_back("<p><b><span>Commands, attributes and");
	str_desc.push_back("properties detailed description.</b></p>");
	str_desc.push_back("<p></p>");
	str_desc.push_back("<p>The following symbols are used:</p>");
	str_desc.push_back("<p></p>");
	str_desc.push_back("<div align=\"center\">");
	str_desc.push_back("<table class=\"MsoTableGrid\" width=\"583\" border=\"1\" cellspacing=\"0\" cellpadding=\"0\">");
	str_desc.push_back("<tbody>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"67\">");
	str_desc.push_back("<p><b>Symbol</b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"258\">");
	str_desc.push_back("<p><b>meaning</b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"258\">");
	str_desc.push_back("<p><b>Attribute /property</b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"67\">");
	str_desc.push_back("<p>I</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"258\">");
	str_desc.push_back("<p>current</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"258\">");
	str_desc.push_back("<p>Attribute</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"67\">");
	str_desc.push_back("<p>I_ideal</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"258\">");
	str_desc.push_back("<p>current setpoint</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"258\">");
	str_desc.push_back("<p>Attribute</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"67\">");
	str_desc.push_back("<p>I_ref</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"258\">");
	str_desc.push_back("<p>current reference</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"258\">");
	str_desc.push_back("<p>Attribute</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"67\">");
	str_desc.push_back("<p>o</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"258\">");
	str_desc.push_back("<p>offset</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"258\">");
	str_desc.push_back("<p>Attribute</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"67\">");
	str_desc.push_back("<p>f</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"258\">");
	str_desc.push_back("<p>current factor</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"258\">");
	str_desc.push_back("<p>Property</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("</tbody>");
	str_desc.push_back("</table>");
	str_desc.push_back("</div>");
	str_desc.push_back("<p></p>");
	str_desc.push_back("<p>In most of the cases the default values of 'offset' and 'current factor' should be set:</p>");
	str_desc.push_back("<p>o = 0</p>");
	str_desc.push_back("<p>f = 1</p>");
	str_desc.push_back("<p>Change of the default setting should be done only in the");
	str_desc.push_back("case User knows what he/she is doing !!!!</p>");
	str_desc.push_back("<p></p>");
	str_desc.push_back("<p><b><u><span>Attributes: </span></u></b></p>");
	str_desc.push_back("<table class=\"MsoTableGrid\" border=\"1\" cellspacing=\"0\" cellpadding=\"0\" align=\"center\">");
	str_desc.push_back("<tbody>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"187\">");
	str_desc.push_back("<p><b>Name</b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"396\">");
	str_desc.push_back("<p><b>Description </b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"187\">");
	str_desc.push_back("<p><b>Current</b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"396\">");
	str_desc.push_back("<p>current calculated out of measured ( by PSC ) current");
	str_desc.push_back("according to the following formula:</p>");
	str_desc.push_back("<p align=\"center\" style=\"text-align: center;\">I = I_ideal + (");
	str_desc.push_back("I_ref &#45; I_measured ) / f</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"187\">");
	str_desc.push_back("<p><b>CurrentSetpoint</b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"396\">");
	str_desc.push_back("<p>the ideal current which is intended to be acquired, it is");
	str_desc.push_back("not the current set to the hardware, the current set in the hardware is");
	str_desc.push_back("calculated according to the following formula:</p>");
	str_desc.push_back("( I_ideal + o )</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"187\">");
	str_desc.push_back("<p><b>CurrentOffset</b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"396\">");
	str_desc.push_back("<p>a value added to the current written to the 'current");
	str_desc.push_back("setpoint' attribute</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"187\">");
	str_desc.push_back("<p><b>CurrentReference</b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"396\">");
	str_desc.push_back("<p>the current value written to the hardware</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"187\">");
	str_desc.push_back("<p><b>CurrentMeasured</b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"396\">");
	str_desc.push_back("<p>current measurement read from the hardware</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"187\">");
	str_desc.push_back("<p><b>Errors</b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"396\">");
	str_desc.push_back("<p>returns readable information about all the errors which");
	str_desc.push_back("have occurred. If error occurs more then one time, it is not duplicated in");
	str_desc.push_back("the return table</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"187\">");
	str_desc.push_back("<p><b>ErrorCodes</b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"396\">");
	str_desc.push_back("<p>returns codes of the latest errors detected according to");
	str_desc.push_back("categories stored in <b>ErrorLabel</b>");
	str_desc.push_back("attribute</p>");
	str_desc.push_back("<p></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"187\">");
	str_desc.push_back("<p><b>ErrorLabel</b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"396\">");
	str_desc.push_back("<p> returns the categories of the error codes</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"187\">");
	str_desc.push_back("<p><b>RemoteMode</b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"396\">");
	str_desc.push_back("<p>is glued to 1 (means remote mode) because PSC can only");
	str_desc.push_back("be operated remotely</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"187\">");
	str_desc.push_back("<p><b>State</b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"396\">");
	str_desc.push_back("<p>returns device state (short message)</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"187\">");
	str_desc.push_back("<p><b>Status</b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"396\">");
	str_desc.push_back("<p>returns human readable, textual description</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"187\">");
	str_desc.push_back("<p><b>Voltage</b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"396\">");
	str_desc.push_back("<p>returns voltage measured on the load</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("</tbody>");
	str_desc.push_back("</table>");
	str_desc.push_back("<div align=\"center\"></div>");
	str_desc.push_back("<div align=\"center\"></div>");
	str_desc.push_back("<div align=\"center\"></div>");
	str_desc.push_back("<div align=\"center\"></div>");
	str_desc.push_back("<p align=\"center\"><b><u><span><span> </span></span></u></b></p>");
	str_desc.push_back("<p><b><u><span>Properties:</span></u></b></p>");
	str_desc.push_back("<table class=\"MsoTableGrid\" border=\"1\" cellspacing=\"0\" cellpadding=\"0\" align=\"center\">");
	str_desc.push_back("<tbody>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"189\">");
	str_desc.push_back("<p><b>Name</b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"407\">");
	str_desc.push_back("<p><b>Description</b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"189\">");
	str_desc.push_back("<p><b>Channel</b><b><u><span></span></u></b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"407\">");
	str_desc.push_back("<p>(0 or 1) defines IP channel used to connect PSC by fiber</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"189\">");
	str_desc.push_back("<p><b>ConnectionType</b><b><u><span></span></u></b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"407\">");
	str_desc.push_back("<p>(0 &#45; fiber; 1 &#45; serial) determines which hardware medium");
	str_desc.push_back("is used to connect industrial PC with PSC</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"189\">");
	str_desc.push_back("<p><b>FODevice</b><b><u><span></span></u></b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"407\">");
	str_desc.push_back("<p>defines device used for fiber optic connection (ex.");
	str_desc.push_back("/dev/pscip0)</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"189\">");
	str_desc.push_back("<p><b>TangoDevice</b><b><u><span></span></u></b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"407\">");
	str_desc.push_back("<p>defines name and location of PySerial DS used for serial");
	str_desc.push_back("communication</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"189\">");
	str_desc.push_back("<p><b>Current factor</b><b><u><span></span></u></b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"407\">");
	str_desc.push_back("<p>multiplier</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"189\">");
	str_desc.push_back("<p><b>InterlockFlowBit");
	str_desc.push_back("InterlockTemperatureBit</b><b><u><span></span></u></b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"407\">");
	str_desc.push_back("<p>'flow' interlock and 'temperature'  interlock signals are");
	str_desc.push_back("represented in 'Digital_Input_Signals' register of PSC as bits. The");
	str_desc.push_back("properties allow user to determine which bits of the PSC register are");
	str_desc.push_back("associated with this interlocks. If correctly defined, these properties");
	str_desc.push_back("enable DS to recognize Flow and Temperature interlocks and provide user with");
	str_desc.push_back("appropriate error message</p>");
	str_desc.push_back("<p><b><u><span><span> </span></span></u></b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("</tbody>");
	str_desc.push_back("</table>");
	str_desc.push_back("<div align=\"center\"></div>");
	str_desc.push_back("<p align=\"center\"><br /><b><u><span><span></span></span></u></b></p>");
	str_desc.push_back("<p align=\"left\"><b><u><span><span>Commands:<br /></span></span></u></b></p>");
	str_desc.push_back("<table class=\"MsoTableGrid\" border=\"1\" cellspacing=\"0\" cellpadding=\"0\" align=\"center\">");
	str_desc.push_back("<tbody>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"187\">");
	str_desc.push_back("<p><b>Name</b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"403\">");
	str_desc.push_back("<p>Description</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"187\">");
	str_desc.push_back("<p><b>ClearError</b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"403\">");
	str_desc.push_back("<p>clear Disorder register in PSC, Error and ErrorCodes");
	str_desc.push_back("attributes in DS</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"187\">");
	str_desc.push_back("<p><b>Disable_interlocks</b><b><span></span></b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"403\">");
	str_desc.push_back("<p>write Digital_Input_Signals_Mask with 0xE070 value. I");
	str_desc.push_back("causes all the interlocks, except one, to be disabled. The not disabled");
	str_desc.push_back("interlock has input at the rear of PSC and can be disabled hardware-wise. The");
	str_desc.push_back("change of Mask register value is temporary.</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"187\">");
	str_desc.push_back("<p><b>Enable_interlocks</b><b><span></span></b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"403\">");
	str_desc.push_back("<p>write Digital_Input_Signals_Mask with 0xF877 value.");
	str_desc.push_back("Interlocks are enabled<b><span></span></b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"187\">");
	str_desc.push_back("<p><b>Interlocks_state</b><b><span></span></b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"403\">");
	str_desc.push_back("<p>shows the current value of<span>");
	str_desc.push_back("</span>Digital_Input_Signals_Mask, Three states: 'Interlocks enabled',");
	str_desc.push_back("'Interlocks disabled' or<span>  </span>'Interlocks");
	str_desc.push_back("customized'</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"187\">");
	str_desc.push_back("<p><b>Init</b><b><span></span></b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"403\">");
	str_desc.push_back("<p></p>");
	str_desc.push_back("<p>default function which re-initialize Device Server not");
	str_desc.push_back("affecting the state of the hardware</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"187\">");
	str_desc.push_back("<p><b>Off</b><b><span></span></b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"403\">");
	str_desc.push_back("<p>turns off the device<b><span></span></b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"187\">");
	str_desc.push_back("<p><b>On</b><b><span></span></b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"403\">");
	str_desc.push_back("<p>turns on the device</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"187\">");
	str_desc.push_back("<p><b>Read_PSC_register</b><b><span></span></b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"403\">");
	str_desc.push_back("<p>enable user to read any PSC register which is");
	str_desc.push_back("read-enabled. The address and (optionally) format of output data need to be");
	str_desc.push_back("specified. The default format is hexadecimal. Example input data '0x00' will");
	str_desc.push_back("read register 0x00 and output it data as hexadecimal, '0x00 f' will read");
	str_desc.push_back("register 0x00 and output it as flaot</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"187\">");
	str_desc.push_back("<p><b>Reset</b><b><span></span></b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"403\">");
	str_desc.push_back("<p>resets PSC by turning it off, an attempt to reestablish");
	str_desc.push_back("connection with hardware is taken if it has been lost. It also calls");
	str_desc.push_back("ClearErrors command<b><span></span></b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("<tr>");
	str_desc.push_back("<td valign=\"top\" width=\"187\">");
	str_desc.push_back("<p><b>State </b></p>");
	str_desc.push_back("<p><b>Status</b><b><span></span></b></p>");
	str_desc.push_back("</td>");
	str_desc.push_back("<td valign=\"top\" width=\"403\">");
	str_desc.push_back("<p>the same as attributes</p>");
	str_desc.push_back("</td>");
	str_desc.push_back("</tr>");
	str_desc.push_back("</tbody>");
	str_desc.push_back("</table>");
	str_desc.push_back("<div align=\"center\"></div>");
	str_desc.push_back("<p align=\"center\"></p>");
	str_desc.push_back("<p></p>");
	str_desc.push_back("<p></p>");
	str_desc.push_back("<p></p>");
	description << str_desc;
	data.push_back(description);
		
	//	put cvs or svn location
	string	filename(classname);
	filename += "Class.cpp";
	
	// Create a string with the class ID to
	// get the string into the binary
	string	class_id(ClassId);
	
	// check for cvs information
	string	src_path(CvsPath);
	start = src_path.find("/");
	if (start!=string::npos)
	{
		end   = src_path.find(filename);
		if (end>start)
		{
			string	strloc = src_path.substr(start, end-start);
			//	Check if specific repository
			start = strloc.find("/cvsroot/");
			if (start!=string::npos && start>0)
			{
				string	repository = strloc.substr(0, start);
				if (repository.find("/segfs/")!=string::npos)
					strloc = "ESRF:" + strloc.substr(start, strloc.length()-start);
			}
			Tango::DbDatum	cvs_loc("cvs_location");
			cvs_loc << strloc;
			data.push_back(cvs_loc);
		}
	}
	// check for svn information
	else
	{
		string	src_path(SvnPath);
		start = src_path.find("://");
		if (start!=string::npos)
		{
			end = src_path.find(filename);
			if (end>start)
			{
				header = "$HeadURL: ";
				start = header.length();
				string	strloc = src_path.substr(start, (end-start));
				
				Tango::DbDatum	svn_loc("svn_location");
				svn_loc << strloc;
				data.push_back(svn_loc);
			}
		}
	}

	//	Get CVS or SVN revision tag
	
	// CVS tag
	string	tagname(TagName);
	header = "$Name: ";
	start = header.length();
	string	endstr(" $");
	
	end   = tagname.find(endstr);
	if (end!=string::npos && end>start)
	{
		string	strtag = tagname.substr(start, end-start);
		Tango::DbDatum	cvs_tag("cvs_tag");
		cvs_tag << strtag;
		data.push_back(cvs_tag);
	}
	
	// SVN tag
	string	svnpath(SvnPath);
	header = "$HeadURL: ";
	start = header.length();
	
	end   = svnpath.find(endstr);
	if (end!=string::npos && end>start)
	{
		string	strloc = svnpath.substr(start, end-start);
		
		string tagstr ("/tags/");
		start = strloc.find(tagstr);
		if ( start!=string::npos )
		{
			start = start + tagstr.length();
			end   = strloc.find(filename);
			string	strtag = strloc.substr(start, end-start-1);
			
			Tango::DbDatum	svn_tag("svn_tag");
			svn_tag << strtag;
			data.push_back(svn_tag);
		}
	}

	//	Get URL location
	string	httpServ(HttpServer);
	if (httpServ.length()>0)
	{
		Tango::DbDatum	db_doc_url("doc_url");
		db_doc_url << httpServ;
		data.push_back(db_doc_url);
	}

	//  Put inheritance
	Tango::DbDatum	inher_datum("InheritedFrom");
	vector<string> inheritance;
	inheritance.push_back("Device_4Impl");
	inher_datum << inheritance;
	data.push_back(inher_datum);

	//	Call database and and values
	//--------------------------------------------
	get_db_class()->put_property(data);
}

}	// namespace
